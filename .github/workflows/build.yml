name: Build images

on:
  push:
    branches:
      - master

jobs:
  build:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Moon toolchain
        uses: 'moonrepo/setup-toolchain@v0'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.13.1

      - name: Install pnpm
        run: npm i -g pnpm

      - name: Install deps
        run: pnpm install --frozen-lockfile

      - name: Verify Docker
        run: |
          docker --version
          docker-compose --version || echo "Docker Compose not available"

      - name: Cache Moon workspace and build artifacts
        uses: actions/cache@v3
        with:
          path: |
            .moon/cache
            .moon/toolchain
            .moon/workspace
            .moon/states
            **/node_modules/.cache
            **/.output
            **/dist
            **/build
          key: moon-full-${{ runner.os }}-${{ hashFiles('.moon/workspace.yml', 'pnpm-lock.yaml') }}
          restore-keys: |
            moon-full-${{ runner.os }}-${{ hashFiles('.moon/workspace.yml') }}-
            moon-full-${{ runner.os }}-

      # Create a baseline if this is the first run
      - name: Initialize Moon baseline
        run: |
          if [ ! -f .moon/states/workspace.json ]; then
            echo "No previous Moon state found, initializing baseline..."
            # Run a dry-run build to establish state without actually building
            pnpm moon :build --dry-run --affected || true
          fi

      # Check what's actually affected before running tests
      - name: Check affected projects
        id: affected-check
        run: |
          # Get affected projects and handle Moon's JSON format properly
          AFFECTED_OUTPUT=$(pnpm moon query projects --affected --json)

          # Extract just the project IDs from Moon's JSON response
          AFFECTED_COUNT=$(echo "$AFFECTED_OUTPUT" | jq '.projects | length')
          AFFECTED_IDS=$(echo "$AFFECTED_OUTPUT" | jq -r '.projects[].id' | tr '\n' ',' | sed 's/,$//')

          echo "affected-count=$AFFECTED_COUNT" >> $GITHUB_OUTPUT
          echo "affected-ids=$AFFECTED_IDS" >> $GITHUB_OUTPUT

          # Check if any projects are actually affected
          if [ "$AFFECTED_COUNT" -eq 0 ]; then
            echo "has-affected=false" >> $GITHUB_OUTPUT
            echo "No projects affected, skipping builds"
          else
            echo "has-affected=true" >> $GITHUB_OUTPUT
            echo "Found $AFFECTED_COUNT affected projects: $AFFECTED_IDS"
          fi

      - name: Run affected tests
        if: steps.affected-check.outputs.has-affected == 'true'
        run: pnpm moon :test --affected

      - name: Build and push Docker images
        if: steps.affected-check.outputs.has-affected == 'true'
        run: pnpm moon :setup-docker-swarm --affected

      - name: Configure Git
        if: steps.affected-check.outputs.has-affected == 'true'
        run: |
          git config user.name "GitHub CI Bot"
          git config user.email "ci@yaoshiko.com"

      - name: Trigger deploy
        if: steps.affected-check.outputs.has-affected == 'true'
        run: |
          # Stash any remaining local changes to avoid conflicts
          git stash push -u -m "Temporary stash before deploy"

          # Make sure we have the latest master (including our version commit)
          git fetch origin
          git checkout master
          git pull origin master

          # Check out the deploy branch
          git checkout deploy || git checkout -b deploy

          # Merge master into deploy with all changes
          git merge origin/master --no-ff -m "[CI] Deploy"

          # Apply any stashed changes back
          git stash pop || echo "No stash to apply"

          # Add any additional changes and commit if needed
          git add .
          if ! git diff --staged --quiet; then
            git commit -m "[CI] Add build artifacts to deploy"
          fi

          # Push the deploy branch
          git push origin deploy

      # Always save the Moon state for next run
      - name: Save Moon state for next run
        if: always()
        uses: actions/cache/save@v3
        with:
          path: |
            .moon/cache
            .moon/toolchain
            .moon/workspace
            .moon/states
            **/node_modules/.cache
            **/.output
            **/dist
            **/build
          key: moon-full-${{ runner.os }}-${{ hashFiles('.moon/workspace.yml', 'pnpm-lock.yaml') }}
